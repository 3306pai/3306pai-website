<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://3306pai.cn/blog</id>
    <title>3306π Blog</title>
    <updated>2021-11-22T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://3306pai.cn/blog"/>
    <subtitle>3306π Blog</subtitle>
    <icon>https://3306pai.cn/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Databend architecture]]></title>
        <id>databend-architecture</id>
        <link href="https://3306pai.cn/blog/databend-architecture"/>
        <updated>2021-11-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Databend 整体架构]]></summary>
        <content type="html"><![CDATA[<p>Databend 是一个开源的、完全面向云架构的新式数仓，它提供快速的弹性扩展能力，并结合云的弹性、简单性和低成本，使 Data Cloud 构建变得更加容易。
Databend 把数据存储在像 AWS S3 ，Azure Blob 这些云上的存储系统，可以使不同的计算节点挂载同一份数据，从而做到较高的弹性，实现对资源的精细化控制。</p><h1>Databend architecture</h1><p>Databend 是一个开源的、完全面向云架构的新式数仓，它提供快速的弹性扩展能力，并结合云的弹性、简单性和低成本，使 Data Cloud 构建变得更加容易。
Databend 把数据存储在像 AWS S3 ，Azure Blob 这些云上的存储系统，可以使不同的计算节点挂载同一份数据，从而做到较高的弹性，实现对资源的精细化控制。
Databend 在设计上专注以下能力：</p><ul><li>弹性 在 Databend 中，存储和计算资源可以按需、按量弹性扩展。</li><li>安全 Databend 中数据文件和网络传输都是端到端加密，并在 SQL 级别提供基于角色的权限控制。</li><li>易用 Databend 兼容 ANSI SQL，并可以使用 MySQL 和 ClickHouse 客户端接入，几乎无学习成本。</li><li>成本 Databend 处理查询非常高效，用户只需要为使用的资源付费。</li></ul><p><img src="https://datafuse-1255499614.cos.ap-beijing.myqcloud.com/architecture_v1.png"/></p><p>上图是 Databend 的整体架构图，整个系统主要由三大部分组成：Meta service layer、Compute Layer 和 Storage Layer。</p><h2>1、Meta Service Layer</h2><ul><li>Meta Service 是一个多租户、高可用的分布式 key-value 存储服务，具备事务能力，主要用于存储：</li><li>Metadata : 表的元信息、索引信息、集群信息、事务信息等。</li><li>Administration：用户系统、用户权限等信息。</li><li>Security ：用户登录认证、数据加密等。</li></ul><h2>2、Compute Layer</h2><p>计算层由多个集群（cluster）组成，不同集群可以承担不同的工作负载，每个集群又有多个计算节点（node）组成，你可以轻松的添加、删除节点或集群，做到资源的按需、按量管理。
计算节点是计算层的最小构成单元，其中每个计算节点包含以下几个组件：
执行计划 （Planner）
根据用户输入的 SQL 生成执行计划，它只是个逻辑表达，并不能真正的执行，而是用于指导整个计算流水线（Pipeline）的编排与生成。
比如语句</p><pre><code>SELECT number + 1 FROM numbers_mt(10) WHERE number &gt; 8 LIMIT 2 
</code></pre><p>执行计划：</p><pre><code>databend :) EXPLAIN SELECT number + 1 FROM numbers_mt(10) WHERE number &gt; 8 LIMIT 2
┌─explain────────────────────────────────────────────────────────────────────────────────────────────┐
│ Limit: 2                                                                                                                │
│   Projection: (number + 1):UInt64                                                                                       │
│     Expression: (number + 1):UInt64 (Before Projection)                                                                 │
│       Filter: (number &gt; 8)                                                                                              │
│         ReadDataSource: scan partitions: [1], scan schema: [number:UInt64], statistics: [read_rows: 10, read_bytes: 80] │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
</code></pre><p>这个执行计划自下而上分别是 ：</p><ul><li><p>ReadDataSource：表示从哪些文件里读取数据</p></li><li><p>Filter: 表示要做 (number &gt; 8) 表达式过滤</p></li><li><p>Expression: 表示要做 (number + 1) 表达式运算</p></li><li><p>Projection: 表示查询列是哪些</p></li><li><p>Limit: 表示取前 2 条数据</p></li></ul><h3>优化器 （Optimizer）</h3><p>对执行计划做一些基于规则的优化（A Rule Based Optimizer）, 比如做一些谓词下推或是去掉一些不必要的列等，以使整个执行计划更优。</p><h3>处理器 （Processors）</h3><p>处理器（Processor）是执行计算逻辑的核心组件。根据执行计划，处理器们被编排成一个流水线（Pipeline），用于执行计算任务。
整个 Pipeline 是一个有向无环图，每个点是一个处理器，每条边由处理器的 InPort 和 OutPort 相连构成，数据到达不同的处理器进行计算后，通过边流向下一个处理器，多个处理器可以并行计算，在集群模式下还可以跨节点分布式执行，这是 Datafuse 高性能的一个重要设计。</p><p>例如，我们可以通过 EXPLAIN PIPELINE 来查看：</p><pre><code>databend :) EXPLAIN PIPELINE SELECT number + 1 FROM numbers_mt(10000) WHERE number &gt; 8 LIMIT 2
┌─explain───────────────────────────────────────────────────────────────┐
│ LimitTransform × 1 processor                                                                              │
│   Merge (ProjectionTransform × 16 processors) to (LimitTransform × 1)     │
│     ProjectionTransform × 16 processors                                                             │
│       ExpressionTransform × 16 processors                                                         │
│         FilterTransform × 16 processors                                                                 │
│           SourceTransform × 16 processors                                                           │
└───────────────────────────────────────────────────────────────────────┘
</code></pre><p>同样，理解这个 Pipeline 我们自下而上来看：</p><ul><li>SourceTransform：读取数据文件，16 个物理 CPU 并行处理</li><li>ilterTransform：对数据进行 (number &gt;  8) 表达式过滤，16 个物理 CPU 并行处理 </li><li>pressionTransform：对数据进行 (number + 1) 表达式执行，16 个物理 CPU 并行处理 </li><li>ojectionTransform：对数据处理生成最终列 </li><li>LimitTransform：对数据进行 Limit 2 处理，Pipeline 进行折叠，由一个物理 CPU 来执行 </li><li>Databend 通过 Pipeline 并行模型，并结合向量计算最大限度的去压榨 CPU 资源，以加速计算。</li></ul><h3>缓存 ( Cache )</h3><p>计算节点使用本地 SSD 缓存数据和索引，以提高数据亲和性来加速计算。
缓存的预热方式有：
LOAD_ON_DEMAND - 按需加载索引或数据块（默认）。
LOAD_INDEX - 只加载索引。
LOAD_ALL - 加载全部的数据和索引，对于较小的表可以采取这种模式。</p><h2>3. Storage Layer</h2><p>Databend 使用 Parquet 列式存储格式来储存数据，为了加快查找（Partition Pruning），Databend  为每个 Parquet 提供了自己的索引（根据 Primary Key 生成）：
min_max.idx Parquet 文件 minimum 和 maximum 值
sparse.idx 以 N 条记录为颗粒度的稀疏索引
通过这些索引， 我们可以减少数据的交互，并使计算量大大减少。
假设有两个Parquet 文件：f1, f2，f1 的 min_max.idx: <!-- -->[3, 5]<!-- --> ；f2 的 min_max.idx: <!-- -->[4, 6]<!-- --> 。如果查询条件为：where x &lt; 4 ， 我们只需要 f1 文件就可以，再根据 sparse.idx 索引定位到 f1 文件中的某个数据页。</p><h2>项目地址</h2><p>代码地址：
<a href="https://github.com/datafuselabs/databend">https://github.com/datafuselabs/databend</a></p><p>项目官网：
<a href="https://datafuse.rs">https://datafuse.rs</a></p><p>想了解我们更多可以关注公众号： Databend .</p>]]></content>
        <author>
            <name>BohuTang</name>
            <uri>https://bohutang.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[技术分享 | MySQL进程号、连接ID、查询ID、InnoDB线程与系统线程如何对应]]></title>
        <id>howto-find-out-os-mysql-innodb-thread</id>
        <link href="https://3306pai.cn/blog/howto-find-out-os-mysql-innodb-thread"/>
        <updated>2021-11-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[如何快速找出操作系统、MySQL进程、连接ID、查询ID、InnoDB内部线程ID之间的关系]]></summary>
        <content type="html"><![CDATA[<h2>导读</h2><blockquote><p>一文快速掌握 MySQL进程号、连接ID、查询ID、InnoDB线程与系统线程的对应关系。</p></blockquote><p>有时候，怀疑某个MySQL内存查询导致CPU或磁盘I/O消耗特别高，但又不确定具体是哪个SQL引起的。</p><p>或者当InnoDB引擎内部有semaphore wait时，想知道具体是哪个线程/查询引起的。多说一下，当有semaphore wait事件超过600秒的话，InnoDB会发出crash信号：</p><pre><code>InnoDB: ###### Diagnostic info printed to the standard error stream
2020-12-13T09:41:33.810011Z 0 [ERROR] [FATAL] InnoDB: Semaphore wait has lasted &gt; 600 seconds. We intentionally crash the server because it appears to be hung.
2020-12-13 10:41:33 0x7f3d92a4e700 InnoDB: Assertion failure in thread 139902430013184 in file ut0ut.cc line 917
InnoDB: We intentionally generate a memory trap.
InnoDB: Submit a detailed bug report to http://bugs.mysql.com.
InnoDB: If you get repeated assertion failures or crashes, even
InnoDB: immediately after the mysqld startup, there may be
InnoDB: corruption in the InnoDB tablespace. Please refer to
InnoDB: http://dev.mysql.com/doc/refman/8.0/en/forcing-innodb-recovery.html
InnoDB: about forcing recovery.
09:41:33 UTC - mysqld got signal 6 ;
</code></pre><p>因此也要监控InnoDB的semaphore wait状态，一旦超过阈值，就要尽快报警并分析出问题原因，及时杀掉或停止引起等待的查询请求。</p><p>不过本文想讨论的是，MySQL的进程ID、内部查询ID、内部线程ID，和操作系统层的进程ID、线程如何对应起来。</p><h2>1、操作系统进程ID</h2><p>MySQL是一个单进程多线程的服务程序，用 <code>ps -ef|grep mysqld</code> 就能看到其系统进程ID了。另外，当 <code>my.cnf</code> 配置文件中增加一行 <code>innodb_status_file = 1</code> 时，也会生成带有系统进程ID的innodb status 文件</p><pre><code>[root@yejr.run]# ps -ef | grep mysqld
mysql    38801     1  0 Jun13 ?        00:03:30 /usr/local/GreatSQL-8.0.22/bin/mysqld --defaults-file=/mysql/data06/my.cnf

[root@yejr.run]# ls -la innodb_status.38801
-rw-r----- 1 mysql mysql 4906 Jun 14 14:26 innodb_status.38801
</code></pre><p>文件 <code>innodb_status.pid</code> 的作用是每隔15秒左右输出innodb引擎各种状态信息，和执行 <code>SHOW ENGINE INNODB STATUS</code> 的作用相同。 二者的区别在于，前者（文件输出方式）的输出内容长度不受限制，而后者（命令行输出）则最多只显示1MB内容，更多的会被截断。所以务必设置 <code>innodb_status_file = 1</code> 选项。</p><pre><code>Standard Monitor output is limited to 1MB when produced using the SHOW ENGINE INNODB STATUS statement. This limit does not apply to output written to server standard error output (stderr).
</code></pre><h2>2、系统线程和MySQL连接ID、查询ID等的关系</h2><p>从MySQL 5.7开始，<code>performance_schema.threads</code> 表增加 <code>THREAD_OS_ID</code> 列，用于记录MySQL内部线程对应的系统线程ID。</p><p>创建一个新连接，并执行下面的SQL：</p><pre><code>[root@yejr.run]# mysql -S./mysql.sock -uroot -p mymgr
...
# 查到MySQL的连接ID是25（PROCESSLIST_ID = 25）
[root@yejr.run] [none]&gt; show processlist;
+----+------+-----------+-------+---------+------+-------+------------------+-----------+---------------+
| Id | User | Host      | db    | Command | Time | State | Info             | Rows_sent | Rows_examined |
+----+------+-----------+-------+---------+------+-------+------------------+-----------+---------------+
| 25 | root | localhost | mymgr | Query   |    0 | init  | show processlist |         0 |             0 |
+----+------+-----------+-------+---------+------+-------+------------------+-----------+---------------+

[root@yejr.run] [mymgr]&gt; begin; select *,sleep(1000) from t1 for update;
...  &lt;-- 这个SQL会运行很长时间，方便我们观察
</code></pre><p>新开一个窗口，查看 <code>pfs.threads</code> 表：</p><pre><code>[root@yejr.run] [performance_schema]&gt; SELECT * FROM threads WHERE PROCESSLIST_ID=25\G
*************************** 1. row ***************************
          THREAD_ID: 65  &lt;-- MySQL内部线程ID，也是PFS的内部计数器
               NAME: thread/sql/one_connection
               TYPE: FOREGROUND
     PROCESSLIST_ID: 25  &lt;-- MySQL连接ID
   PROCESSLIST_USER: root
   PROCESSLIST_HOST: localhost
     PROCESSLIST_DB: mymgr
PROCESSLIST_COMMAND: Query
   PROCESSLIST_TIME: 246
  PROCESSLIST_STATE: User sleep
   PROCESSLIST_INFO: select *,sleep(1000) from t1 for update  &lt;-- 正在运行的SQL
   PARENT_THREAD_ID: NULL
               ROLE: NULL
       INSTRUMENTED: YES
            HISTORY: YES
    CONNECTION_TYPE: Socket
       THREAD_OS_ID: 58412  &lt;-- 对应操作系统的线程ID
     RESOURCE_GROUP: USR_default
</code></pre><p>运行 <code>ps -Lef</code> 查看对应的系统线程</p><pre><code>[root@yejr.run]# ps -Lef | grep 58412  &lt;-- 上面查询pfs.threads看到 THREAD_OS_ID 列的值
mysql    38801     1 58412  0   40 14:46 ?        00:00:00 /usr/local/GreatSQL-8.0.22/bin/mysqld --defaults-file=/mysql/data06/my.cnf
</code></pre><p>如果设置了 <code>general_log=1</code>，那么也能看到 <strong>general_log</strong> 里有这样的记录：</p><pre><code>[root@yejr.run]# cat yejr.run.log

/usr/local/GreatSQL-8.0.22/bin/mysqld, Version: 8.0.22-13 (Source distribution). started with:
Tcp port: 6001  Unix socket: mysql.sock
#几个列分别是：时间、连接ID、请求类型、详细的SQL
Time                 Id Command    Argument
...
2021-06-14T14:46:47.474393+08:00       25 Query select *,sleep(1000) from t1 for update  &lt;-- 可以看到连接ID是25
...
</code></pre><p>再查询 <code>pfs.events_statements_current</code> 表：</p><pre><code>[root@yejr.run] [performance_schema]&gt; SELECT * FROM events_statements_current WHERE THREAD_ID = 65\G
              THREAD_ID: 65
               EVENT_ID: 8
           END_EVENT_ID: NULL
             EVENT_NAME: statement/sql/select
                 SOURCE: init_net_server_extension.cc:95
            TIMER_START: 82217983305961000
              TIMER_END: 82559992238886000
             TIMER_WAIT: 342008932925000
              LOCK_TIME: 206000000
               SQL_TEXT: select *,sleep(1000) from t1 for update
                 DIGEST: 4d7f4182dff4abc484010b73024b4afb35075e1b6592d14ce895a2b8764b8f46
            DIGEST_TEXT: SELECT * , `sleep` (?) FROM `t1` FOR UPDATE
         CURRENT_SCHEMA: mymgr
...
            SELECT_SCAN: 1
...
       NESTING_EVENT_ID: 6
     NESTING_EVENT_TYPE: TRANSACTION
    NESTING_EVENT_LEVEL: 0
           STATEMENT_ID: 87  &lt;-- 查询ID，每次查询该ID值都会增加

</code></pre><p>执行 <code>SHOW ENGINE INNODB STATUS\G</code> 查看事务状态：</p><pre><code>...
# 事务ID=9322，运行时长=252秒
---TRANSACTION 9322, ACTIVE 252 sec
mysql tables in use 1, locked 1
2 lock struct(s), heap size 1136, 1 row lock(s)
# MySQL连接ID=25，OS线程句柄 = 140442126739200（后面再介绍），查询ID=87（对应上面的 STATEMENT_ID）
MySQL thread id 25, OS thread handle 140442126739200, query id 87 localhost root User sleep
select *,sleep(1000) from t1 for update
...
</code></pre><p>再看下 <code>OS thread handle</code> 和操作系统线程ID的对应关系。</p><p>首先，<code>OS thread handle 140442126739200</code> （OS thread handle是进程内部用于识别各个线程的内部ID）这里是个十进制的数值，需要先转成十六进制（有时候可能会直接用十六进制表示，这个问题也有人提出了 <a href="https://jira.mariadb.org/browse/MDEV-17237">MDEV-17237</a>）：</p><pre><code>[root@yejr.run] [performance_schema]&gt; select lower(conv(140442126739200, 10, 16));
+--------------------------------------+
| lower(conv(140442126739200, 10, 16)) |
+--------------------------------------+
| 7fbb3b136700                         |
+--------------------------------------+
</code></pre><p>再利用 <code>pstack</code> 查询该句柄和操作系统线程ID的关联：</p><pre><code>[root@yejr.run]# pstack `pidof mysqld` | grep 7fbb3b136700
Thread 2 (Thread 0x7fbb3b136700 (LWP 58412)):
</code></pre><p>可以看到 LWP = 58412，对应上面的 <code>THREAD_OS_ID</code> 值，LWP是Light-Weight Processes的缩写（轻量级进程）。用 <code>pidstat</code> 也能看到这个LWP：</p><pre><code>[root@yejr.run]# pidstat -t -p 38801 | grep 58031
03:45:02 PM  1000         -     58031    0.00    0.00    0.00    0.00     2  |__mysqld
</code></pre><p>【特别提醒】<strong>运行pstack会短暂阻塞mysqld进程，所以请切勿在业务高峰期执行，除非万不得已</strong>。</p><p>有时候可能会看到类似下面的 innodb status：</p><pre><code>SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 15143
--Thread 140585128785664 has waited at buf0flu.cc line 1209 for 237 seconds the semaphore:
SX-lock on RW-latch at 0x7fdb1fbe3f80 created in file buf0buf.cc line 1460
a writer (thread id 140584786024192) has reserved it in mode SX
number of readers 0, waiters flag 1, lock_word: 10000000
Last time read locked in file row0sel.cc line 3758
Last time write locked in file /export/home/pb2/build/sb_0-34537258-1560179931.8/mysql-5.7.27/storage/innobase/fsp/fsp0fsp.cc line 167
</code></pre><p>在上面这段信息中，线程 <code>Thread 140585128785664</code> 在 <code>buf0flu.cc代码1209行</code>这里等待了237秒，想要请求 SX-lock 的 RW-latch，被另一个线程 <code>thread id 140584786024192</code> 给阻塞了，它持有的是 SX latch。</p><p>这时候，就可以利用pstack反查对应的LWP，再反查出PROCESSLIST_ID，以及正在执行的SQL。<code>pfs.events_statements_current</code> 中只能查到当前执行的SQL，可以通过 <code>pfs.events_statements_history</code> 查看最近执行过的SQL。</p><p>Enjoy MySQL :)</p><h2>延伸阅读</h2><ul><li>15.17.3 InnoDB Standard Monitor and Lock Monitor Output, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html</a></li><li>27.12.21.6 The threads Table, <a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-threads-table.html">https://dev.mysql.com/doc/refman/8.0/en/performance-schema-threads-table.html</a></li><li>27.12.6.1 The events_statements_current Table, <a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-events-statements-current-table.html">https://dev.mysql.com/doc/refman/8.0/en/performance-schema-events-statements-current-table.html</a></li><li>27.12.6.2 The events_statements_history Table, <a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-events-statements-history-table.html">https://dev.mysql.com/doc/refman/8.0/en/performance-schema-events-statements-history-table.html</a></li></ul>]]></content>
        <author>
            <name>叶金荣</name>
            <uri>https://imysql.com</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库索引总结：模型数空运最快]]></title>
        <id>数据库索引总结：模型数空运最快</id>
        <link href="https://3306pai.cn/blog/2021/11/22/songhua"/>
        <updated>2021-11-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[大家好，我是知数堂SQL 优化班老师 网名：骑龟的兔子]]></summary>
        <content type="html"><![CDATA[<p>大家好，我是知数堂SQL 优化班老师 网名：骑龟的兔子</p><p>我今天刷头条的时候 看到了一位叫《老猿说开发》总结的索引不能使用口诀
模型数空运最快</p><p>我觉得挺好，但是因为没有具体的案例，还有没说是哪个数据库这些需要完善的地方，所以写一篇文章。</p><p>模：模糊查询%在前面情况不能使用索引，这种情况非得说一个特例就是不回表情况</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;desc select dept_no from t_group2 where dept_no like &#x27;%005&#x27;;
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | t_group2 | NULL       | index | NULL          | ix_dept_no2 | 16      | NULL |   10 |    11.11 | Using where; Using index |
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+--------------------------+
</code></pre><p>型：数据类型有变化的时候不能使用</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;desc test1 ;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | varchar(10) | YES  | MUL | NULL    |       |
| n     | varchar(10) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
</code></pre><pre><code>root@mysql3306.sock&gt;[employees]&gt;select * from test1 ;
+------+------+
| id   | n    |
+------+------+
| 1000 | NULL |
| NULL | NULL |
+------+------+
2 rows in set (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;show index from test1 ;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| test1 |          1 | ix_id    |            1 | id          | A         |           2 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
1 row in set (0.01 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id=1000;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test1 | NULL       | ALL  | ix_id         | NULL | NULL    | NULL |    2 |    50.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 3 warnings (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test1 | NULL       | ref  | ix_id         | ix_id | 43      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)
</code></pre><p>数：索引列套用函数不能使用索引，这时候mysql 5.7可以用虚拟列，8.0可以直接使用函数索引，5.6的时候可以利用类似解方程方法解开</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test1 | NULL       | ref  | ix_id         | ix_id | 43      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where concat(id,&#x27;&#x27;)=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test1 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
root@mysql3306.sock&gt;[employees]&gt;create index idx_t1_ke1 on test1((concat(id,&#x27;&#x27;)));
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where concat(id,&#x27;&#x27;)=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test1 | NULL       | ref  | idx_t1_ke1    | idx_t1_ke1 | 43      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
</code></pre><p>空：索引列有空值使用is null 就不能使用索引，这个在oracle 是没问题的
但是在mysql 这个是错的</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;desc test1 ;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | varchar(10) | YES  | MUL | NULL    |       |
| n     | varchar(10) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;select * from test1 ;
+------+------+
| id   | n    |
+------+------+
| 1000 | NULL |
| NULL | NULL |
+------+------+
2 rows in set (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;show index from test1 ;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| test1 |          1 | ix_id    |            1 | id          | A         |           2 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
1 row in set (0.01 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id is null;
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | test1 | NULL       | ref  | ix_id         | ix_id | 43      | const |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id is not  null;
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | test1 | NULL       | range | ix_id         | ix_id | 43      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre><p>运：索引列有数字运算的时候不能使用索引</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
|1| SIMPLE      | test1 | NULL       | ref  | ix_id         | ix_id | 43      | const |    1 |100.00| NULL  |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id+0=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|1| SIMPLE      | test1 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |100.00| Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
</code></pre><p>最：复合索引，最左边原则，这个也需要分情况分版本，因为有skip index的存在</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;show index from dept_emp2 ;
+-----------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table     | Non_unique | Key_name    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-----------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| dept_emp2 |          1 | ix_dept_emp |            1 | dept_no     | A         |           8 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| dept_emp2 |          1 | ix_dept_emp |            2 | emp_no      | A         |      315555 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+-----------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
2 rows in set (0.00 sec)
root@mysql3306.sock&gt;[employees]&gt;desc select * from dept_emp2 where emp_no=10001 limit 10 ;
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | dept_emp2 | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 331008 |    10.00 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select emp_no,dept_no from dept_emp2 where emp_no=10001 limit 10 ;
+----+-------------+-----------+------------+-------+---------------+-------------+---------+------+-------+----------+----------------------------------------+
| id | select_type | table     | partitions | type  | possible_keys | key         | key_len | ref  | rows  | filtered | Extra                                  |
+----+-------------+-----------+------------+-------+---------------+-------------+---------+------+-------+----------+----------------------------------------+
|  1 | SIMPLE      | dept_emp2 | NULL       | range | ix_dept_emp   | ix_dept_emp | 20      | NULL | 33100 |   100.00 | Using where; Using index for skip scan |
+----+-------------+-----------+------------+-------+---------------+-------------+---------+------+-------+----------+----------------------------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre><p>快：如果优化器认为使用全表比使用索引快，那就不会使用索引，说白了就是基于优化器或者统计信息，这个就是所谓的百分比，这里最重要的一点是使用索引一般情况下是回表，也就是发生随机IO,这个随着回表的量的大小变大，一般OLTP都是在表下查询少量数据情况，所以还是使用索引的情况会好</p><p>当然上面的情况之外，还有别的情况，如日期类型，还有字符串比较的时候等等，这些在课堂中有详细的解答。
我是知数堂SQL 优化班老师~ ^^</p><p>最新一期SQL优化课，在12月份开始。</p><p>如有关于SQL优化方面疑问和一起交流的请加 并且 @兔子@知数堂SQL优化</p><p>高性能MySQL,SQL优化群 有叶金荣，吴炳锡 两位大神坐镇 ：579036588</p><p>欢迎加入 知数堂大家庭。</p><p>我的微信公众号：SQL开发与优化(sqlturning)</p>]]></content>
    </entry>
</feed>