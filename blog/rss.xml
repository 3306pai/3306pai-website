<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>3306π Blog</title>
        <link>https://3306pai.cn/blog</link>
        <description>3306π Blog</description>
        <lastBuildDate>Sun, 03 Sep 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[GaussDB(for MySQL) 构筑云原生的竞争力- 许嘉正]]></title>
            <link>https://3306pai.cn/blog/gaussdb-cloud-native-new-power</link>
            <guid>gaussdb-cloud-native-new-power</guid>
            <pubDate>Sun, 03 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[主题]]></description>
            <content:encoded><![CDATA[<h2>主题</h2><p>《GaussDB(for MySQL) 构筑云原生的竞争力》</p><h2>大纲：</h2><p>GaussDB(for MySQL) 作为华为云自研的新一代云原生数据库，依托云上多种多样的基础设施能力，将推出一系列新的高级特性，应答客户对云数据库更高能力的要求，构筑云原生数据库的核心竞争力.
1、关于 GaussDB(for MySQL)
2、GaussDB(for MySQL) 一系列高级特性
3、技术路线的演进和对比</p><h2>作者介绍</h2><p><strong>许嘉正</strong>，GaussDB(for MySQL)产品经理，原GaussDB(for MySQL)内核研发</p><h2>公司介绍</h2><p>华为云</p><h2>公司产品</h2><p>GaussDB(for MySQL) 是华为自研的最新一代高性能企业级分布式关系型数据库，完全兼容MySQL。基于华为最新一代DFV分布式存储，采用计算存储分离架构，最高支持128TB的海量存储，可实现超百万级QPS吞吐，支持跨AZ部署，数据0丢失，既拥有商业数据库的性能和可靠性，又具备开源数据库的灵活性。</p><h2>3306π 数据库朋友</h2><p><a href="https://www.huodongxing.com/event/1716596158000">3306π 数据库朋友</a> : <a href="https://www.huodongxing.com/event/1716596158000">https://www.huodongxing.com/event/1716596158000</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023916.png?wubx"/></p><p>时间：  2023年 9 月16日  13:00 - 18:00</p><p>地点：北京市朝阳区酒仙桥路 6 号院 2 号楼 360 大厦 A 座 F1 发布厅</p><p>提前提问地址： <a href="https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz">https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023-bj-poster.png?wubx"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[PolarDB MySQL计算层在Lego体系下的发展 - 梁辰]]></title>
            <link>https://3306pai.cn/blog/PloarDB-MySQL-2023-3306pai-bj</link>
            <guid>PloarDB-MySQL-2023-3306pai-bj</guid>
            <pubDate>Sun, 03 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[主题]]></description>
            <content:encoded><![CDATA[<h2>主题</h2><p>《PolarDB MySQL计算层在 Lego 体系下的发展》</p><h2>大纲：</h2><p>介绍 PolarDB MySQL 在计算层的相关工作、与整个 PolarDB 发展方向的契合，如何在云上利用异构引擎、异构介质，以更强大的功能、更好的性能满足企业级客户的需求</p><ol><li>PolarDB MySQL整体架构的发展和未来的演进方向</li><li>计算层团队目前几个主要的工作方向，以及在每个方向上，目前做的一些工作</li><li>深入的介绍下1到2个比较亮眼的功能点</li></ol><h2>作者介绍</h2><p><strong>梁辰</strong> 清华大学电子工程系本科,中科院计算所人际交互专业硕士。
目前负责 PolarDB MySQL 计算层的研发工作，从事数据库内核开发约 7 年，工作中主要接触的是 informix 和 MySQL 这两款数据库。对数据库领域比较痴迷，喜欢研究各类系统的架构和实现，尤其关注在优化执行方向。</p><h2>公司介绍</h2><p>阿里云</p><h2>公司产品</h2><p>PolarDB MySQL 是阿里云自研的100%兼容 MySQL的云原生关系型数据库产品，采用计算存储分离的架构，同时具有多主多写、多活容灾、HTAP、数据分层等多种特性。基于云基础设施，通过极致性价比和高价值的企业级特性，持续构建产品核心竞争力。</p><h2>3306π 数据库朋友</h2><p><a href="https://www.huodongxing.com/event/1716596158000">3306π 数据库朋友</a> : <a href="https://www.huodongxing.com/event/1716596158000">https://www.huodongxing.com/event/1716596158000</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023916.png?wubx"/></p><p>时间：  2023年 9 月16日  13:00 - 18:00</p><p>地点：北京市朝阳区酒仙桥路 6 号院 2 号楼 360 大厦 A 座 F1 发布厅</p><p>提前提问地址： <a href="https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz">https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023-bj-poster.png?wubx"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Serverless 数仓技术与挑战 - 张雁飞]]></title>
            <link>https://3306pai.cn/blog/Serverless-warehouse-2023-3306pai-bj</link>
            <guid>Serverless-warehouse-2023-3306pai-bj</guid>
            <pubDate>Sun, 03 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[主题]]></description>
            <content:encoded><![CDATA[<h2>主题</h2><p>《Serverless 数仓技术与挑战》</p><h2>大纲：</h2><p>在本次分享中，我们将介绍一款新型Serverless数仓技术。该技术旨在解决传统数仓在扩展性、成本和管理上的局限性，能够大幅提升性能并降低成本。我们还将探讨Serverless数仓面临的技术挑战。</p><ol><li>传统数仓架构的局限性</li><li>理想的Serverless 数仓架构</li><li>如何实现Serverless 数仓以及有哪些挑战</li></ol><h2>作者介绍</h2><p><strong>张雁飞</strong>，Databend Cloud联合创始人，前阿里云数据库内核组早期成员、前青云数据库团队负责人。开源 Databend 项目主要负责人</p><h2>公司介绍</h2><p>Databend Labs 成立于2021年3月，是一家开源 Data Cloud 服务商，核心团队成员来自 ClickHouse 社区、谷歌 Anthos、阿里云等国内外知名互联网和云计算公司，团队在云原生数据库领域有着丰富的工程经验，研发人员分布在中、美两地，同时也是数据库开源社区活跃贡献者。公司的核心业务，包括：基于对象存储构建的开源云原生数据仓库 Databend ；基于 Databend 的商业产品，为 Databend 用户提供技术支持商业服务；以及研发和推广基于 Databend 打造的易用、低成本、高性能的新一代大数据分析平台 Databend Cloud 。</p><h2>公司产品</h2><p>Databend Cloud 是基于开源云原生数仓项目 Databend 打造的一款易用、低成本、高性能的新一代大数据分析平台，实现按需、按量付费的 Data Cloud, 让你专注于数据价值的挖掘，算你所想。</p><h2>3306π 数据库朋友</h2><p><a href="https://www.huodongxing.com/event/1716596158000">3306π 数据库朋友</a> : <a href="https://www.huodongxing.com/event/1716596158000">https://www.huodongxing.com/event/1716596158000</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023916.png?wubx"/></p><p>时间：  2023年 9 月16日  13:00 - 18:00</p><p>地点：北京市朝阳区酒仙桥路 6 号院 2 号楼 360 大厦 A 座 F1 发布厅</p><p>提前提问地址： <a href="https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz">https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023-bj-poster.png?wubx"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GreatSQL 国产开源新势力 - 叶金荣]]></title>
            <link>https://3306pai.cn/blog/greatsql-new-power-3306pai-bj</link>
            <guid>greatsql-new-power-3306pai-bj</guid>
            <pubDate>Sun, 03 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[主题]]></description>
            <content:encoded><![CDATA[<h2>主题</h2><p>《GreatSQL 国产开源新势力》</p><h2>大纲：</h2><p><strong>GreatSQL</strong> 作为国产开源新势力，是适用于金融级应用的国内自主开源数据库，具备高性能、高可靠、高易用性、高安全等多个核心特性，在本次分享中还会透露未来的新版本特性规划。</p><p>1、关于 GreatSQL
2、GreatSQL 优势特性
3、GreatSQL 新版本规划特性</p><h2>作者介绍</h2><p><strong>叶金荣</strong>，万里数据库开源生态负责人，Oracle MySQL ACE，腾讯云TVP成员，墨天轮MVP</p><h2>公司介绍</h2><p>北京万里开源软件有限公司（简称“万里数据库”）成立于2000年，是专注于国产自主可控数据库产品研发的国家高新技术企业。主要有GreatDB及GreatSQL等产品。</p><h2>公司产品</h2><p><strong>GreatSQL</strong> 是适用于金融级应用的国内自主开源数据库，具备高性能、高可靠、高易用性、高安全等多个核心特性，可以作为 MySQL 或 Percona Server 的可选替换，用于线上生产环境，且完全免费并兼容 MySQL 或 Percona Server</p><h2>3306π 数据库朋友</h2><p><a href="https://www.huodongxing.com/event/1716596158000">3306π 数据库朋友</a> : <a href="https://www.huodongxing.com/event/1716596158000">https://www.huodongxing.com/event/1716596158000</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023916.png?wubx"/></p><p>时间：  2023年 9 月16日  13:00 - 18:00</p><p>地点：北京市朝阳区酒仙桥路 6 号院 2 号楼 360 大厦 A 座 F1 发布厅</p><p>提前提问地址： <a href="https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz">https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023-bj-poster.png?wubx"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2023 年数据库发展现状及展望]]></title>
            <link>https://3306pai.cn/blog/plinux-2023-3306pai-bj</link>
            <guid>plinux-2023-3306pai-bj</guid>
            <pubDate>Sun, 03 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[主题]]></description>
            <content:encoded><![CDATA[<h2>主题</h2><p>《2023 年数据库发展现状及展望》</p><ul><li>彭立勋 / 华为云</li><li>梁辰 / 阿里云</li></ul><h2>作者介绍</h2><ol><li><p><strong>彭立勋</strong>，15+年数据库运维、架构、内核研发经验，一直活跃在MySQL社区，MySQL Contributor &amp; MariaDB Committer，Oracle ACE (for MySQL)。《高性能MySQL（第三版）》译者之一，中国计算机行业协会-数据库专委会副会长，中国MySQL用户组主席。</p></li><li><p><strong>梁辰</strong>， 清华大学电子工程系本科, 中科院计算所人际交互专业硕士。目前负责PolarDB MySQL计算层的研发工作。从事数据库内核开发约7年，工作中主要接触的是informix和MySQL这两款数据库。对数据库领域比较痴迷，喜欢研究各类系统的架构和实现，尤其关注在优化执行方向。</p></li></ol><h2>3306π 数据库朋友</h2><p><a href="https://www.huodongxing.com/event/1716596158000">3306π 数据库朋友</a> : <a href="https://www.huodongxing.com/event/1716596158000">https://www.huodongxing.com/event/1716596158000</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023916.png?wubx"/></p><p>时间：  2023年 9 月16日  13:00 - 18:00</p><p>地点：北京市朝阳区酒仙桥路 6 号院 2 号楼 360 大厦 A 座 F1 发布厅</p><p>提前提问地址： <a href="https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz">https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023-bj-poster.png?wubx"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MySQL的最新版本8.1及MySQL的安全性-徐轶韬]]></title>
            <link>https://3306pai.cn/blog/mysql-8.1-feture-2023-3306pai-bj</link>
            <guid>mysql-8.1-feture-2023-3306pai-bj</guid>
            <pubDate>Sun, 03 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[主题]]></description>
            <content:encoded><![CDATA[<h2>主题</h2><p>《MySQL的最新版本8.1及MySQL的安全性》</p><h2>大纲：</h2><p>本次分享将介绍MySQL最新的版本8.1,MySQL的安全性及未来MySQL的版本发布方式。</p><ol><li>  MySQL8.1的新特性</li><li>  MySQL的安全性</li><li>  MySQL的版本发布方式</li></ol><h2>作者介绍</h2><p><strong>徐轶韬</strong>，MySQL解决方案首席工程师。为中国金融、政府、航空运输等行业的MySQL用户提供相关产品的售前咨询，企业级产品介绍服务以及推广和普及MySQL数据库在社区的使用。公众号“MySQL解决方案工程师”运营者和内容作者。《MySQL高可用解决方案——从主复制到InnoDB Cluster架构》作者。</p><h2>公司介绍</h2><p>Oracle 是 <strong>全球最大的企业级软件公司</strong>，总部位于美国 加利福尼亚州 的红木滩。 1989年正式进入中国市场。 2013年 ，甲骨文已超越 <em>IBM</em> ，成为继 <em>Microsoft</em> 后<strong>全球</strong>第二大软件公司。</p><h2>公司产品</h2><p><strong>MySQL</strong>  全球最流行的开源数据库。</p><h2>3306π 数据库朋友</h2><p><a href="https://www.huodongxing.com/event/1716596158000">3306π 数据库朋友</a> : <a href="https://www.huodongxing.com/event/1716596158000">https://www.huodongxing.com/event/1716596158000</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023916.png?wubx"/></p><p>时间：  2023年 9 月16日  13:00 - 18:00</p><p>地点：北京市朝阳区酒仙桥路 6 号院 2 号楼 360 大厦 A 座 F1 发布厅</p><p>提前提问地址： <a href="https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz">https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023-bj-poster.png?wubx"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[为什么功能强大的PostgreSQL没有MySQL流行-叶正盛]]></title>
            <link>https://3306pai.cn/blog/mysql-vs-postgresql-2023-3306pai-bj</link>
            <guid>mysql-vs-postgresql-2023-3306pai-bj</guid>
            <pubDate>Sun, 03 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[主题]]></description>
            <content:encoded><![CDATA[<h2>主题</h2><p>《为什么功能强大的PostgreSQL没有MySQL流行》</p><h2>大纲：</h2><p>PostgreSQL是业界功能最强大的开源数据库，为什么在全球流行度没有MySQL高，本次分享主题计划从产品、技术、商业等方面综合分析两个数据库的竞争</p><ol><li>PostgreSQL与MySQL数据库简介</li><li>市场分析</li><li>产品定位</li><li>技术优劣势</li><li>未来趋势</li></ol><h2>作者介绍</h2><p><strong>叶正盛</strong>，玖章算术CEO，NineData程序员，原阿里云数据库产品管理与解决方案部总经理，资深数据库专家</p><h2>公司介绍</h2><p>NineData使用了领先的云原生与AIGC技术，面向云与AI时代架构设计，是业界首个支持跨云和本地IDC无缝打通的智能数据管理平台，包括SQL开发、数据复制与对比、数据备份几大产品，可以帮助客户轻松完成数据上云、跨云数据实时传输、ETL、数据备份、企业级智能SQL开发、数据库研发规范、生产变更、敏感数据管理等能力，让客户的数据使用更安全、更高效。</p><h2>公司产品</h2><p><strong>MySQL</strong>  全球最流行的开源数据库。</p><h2>3306π 数据库朋友</h2><p><a href="https://www.huodongxing.com/event/1716596158000">3306π 数据库朋友</a> : <a href="https://www.huodongxing.com/event/1716596158000">https://www.huodongxing.com/event/1716596158000</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023916.png?wubx"/></p><p>时间：  2023年 9 月16日  13:00 - 18:00</p><p>地点：北京市朝阳区酒仙桥路 6 号院 2 号楼 360 大厦 A 座 F1 发布厅</p><p>提前提问地址： <a href="https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz">https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023-bj-poster.png?wubx"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TensorDB 使用 GPU 检索的向量数据库 - 阎虎青]]></title>
            <link>https://3306pai.cn/blog/tensordb-use-gpu-vector-2023-3306pai-bj</link>
            <guid>tensordb-use-gpu-vector-2023-3306pai-bj</guid>
            <pubDate>Sun, 03 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[主题]]></description>
            <content:encoded><![CDATA[<h2>主题</h2><p>《TensorDB 使用 GPU 检索的向量数据库》</p><h2>大纲：</h2><p>介绍向量数据库的背景与解决的问题，以及Tensordb实现特点和异构计算的一些成果</p><h2>作者介绍</h2><p><strong>阎虎青</strong>，负责爱可生向量数据库开发工作，专注于数据库方面的技术, 始终在一线从事开发，玩过数据复制，读写分离，分库分表，现在正为“炼丹时代”打造向量数据库工具</p><h2>公司介绍</h2><p>爱可生，国内开源数据库服务及数据库平台解决方案的龙头公司，致力于数据库领域，为客户提供企业级的数据库全生态软件产品和服务。
产品主要涵盖：多数据库自动化运维管理平台（云树DMP）、数据库云服务平台（云树RDS）、分布式数据库（云树Shard）、SQL审核平台（SQLE）、数据同步工具（DTS）等软件产品，以及多中心容灾建设、数据迁移等解决方案。
爱可生成立于2003年，总部和研发中心位于上海，下设北京、深圳等分公司，拥有15+年大型系统平台运维经验，位列全球TOP10规模的系统建设及运维经验、 1000+运维项目经验。
近3年私有云市场MySQL产品&amp;运维服务领导地位，得到行业客户的广泛认可，拥有多家世界500强客户及大型银行客户，在金融行业树立标杆地位。</p><h2>公司产品</h2><p>TensorDB® — 爱可生向量数据库企业版软件
TensorDB实现了超大规模向量型数据的高效组织，可以有效支撑时变环境下的向量数据快速比对，面向复杂场景下的实体分析与关系推断， TensorDB克服了 AI 领域多样化应用面临的非结构化数据管理与处理分析困难，提升了数据库异构融合能力。TensorDB 具有极高的并发检索性能，支持卓越的水平拓展能力， 并提供满足多元业务场景下的高可用需求。TensorDB 致力于为用户提供一站式非结构化数据处理与检索解决方案。</p><h2>3306π 数据库朋友</h2><p><a href="https://www.huodongxing.com/event/1716596158000">3306π 数据库朋友</a> : <a href="https://www.huodongxing.com/event/1716596158000">https://www.huodongxing.com/event/1716596158000</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023916.png?wubx"/></p><p>时间：  2023年 9 月16日  13:00 - 18:00</p><p>地点：北京市朝阳区酒仙桥路 6 号院 2 号楼 360 大厦 A 座 F1 发布厅</p><p>提前提问地址： <a href="https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz">https://docs.qq.com/form/page/DTlVDVEtqcFFTQWhz</a></p><p><img src="https://wubx-1255499614.cos.ap-nanjing.myqcloud.com/image/3306pai-2023-bj-poster.png?wubx"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[开源云原生数仓 Databend--张雁飞 (BohuTANG) | Datafuse Labs]]></title>
            <link>https://3306pai.cn/blog/bohutang-sz-interview-2021</link>
            <guid>bohutang-sz-interview-2021</guid>
            <pubDate>Sun, 12 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[问题一]]></description>
            <content:encoded><![CDATA[<p><img src="https://3306pai-1255499614.cos.ap-guangzhou.myqcloud.com/sz2021/%E5%BC%A0%E9%9B%81%E9%A3%9E.jpg"/></p><h2>问题一</h2><p><strong>小编：</strong> 虎哥现在你对外挂的 Title 是：Datafuse Labs 联合创始人，对外的开源产品是 Databend , 这两者是什么关系呢？</p><p><strong>BohuTang:</strong> Databend 是一个使用 Rust 研发、开源、完全面向云架构的新式数仓，提供极速的弹性扩展能力，致力于打造按需、按量的 Data Cloud 产品体验。</p><p>「Datafuse Labs」成立于 2021 年 3 月，是开源项目 Databend 的背后团队，团队在云原生数据库领域有着丰富的工程经验，同时也是数据库开源社区活跃贡献者，目前在中国、美国、新加坡均设有研发中心，专注于前沿技术领域的创新与实践，以及 Databend 开源生态、社区构建。
目前 Datafuse Labs 组建了 一个Worldwide Remote 式办公的国际化数据库研发团队，同时也欢迎大家关注 Databend 这个结合云调度能力和弹性的新式数仓：<a href="https://github.com/datafuselabs/databend">https://github.com/datafuselabs/databend</a></p><h2>问题二</h2><p><strong>小编：</strong> 听虎哥您介绍 Databend 是定位云原生开源的数仓系统，对于云原生数仓系统，您认为主要的挑战在哪里？</p><p><strong>BohuTang:</strong>  对于云原生这个概念，相信很多人也非常的模糊，或是很多朋友认为云厂商的数仓产品就是云原生数仓，其实这个理解是有问题的。可以先不纠结云原生数仓这个概念，我们先来看看从用户角度对数仓需求的几个层次：</p><ol><li>不想采购硬件来安装数仓软件 - 这个非常容易满足，云主机就可以</li><li>不想运维数仓软件，比如管理版本升级等 - 这个需求也比较容易满足，大部分云厂商的数仓PaaS就可以</li><li>秒级的弹性扩展能力 - 这个需求满足起来会比较困难，要求数仓从架构上针对云基础设施进行重设计，比如做存算分离等</li><li>只为使用的资源付费 - 这个需求满足起来会非常困难，要求数仓对资源的控制和调度做到非常精细化
目前大部分数仓产品做到了第 2 层次，Snowflake 做到了 3 和 4， 这里最大的挑战就是 3 和 4。以当前的大环境来看，这两个需求借助于云基础设施才可以做到，所以 Databend 从第一天起就是完全面向云架构设计， 我们做了大量的工作来让状态和计算分离，致力于满足这两个需求。</li></ol><h2>问题三</h2><p><strong>小编：</strong> 对于数据库内核开发我们觉得是一个门槛很高的活，想咨询一下虎哥，现阶段你们公司的团队是一个什么样规模以及您怎么快速的组建的这个团队？你们现在的工作方式大概是什么样的？</p><p><strong>BohuTang:</strong>  数据库内核，尤其是 Cloud Data Warehouse 研发是一个很酷和充满挑战的工作，因为这块目前还是个荒地，我们也是一边探索一边工程实践，正因如此才充满了乐趣。
在组建 Databend 内核研发团队时，我们把眼光放到了全球，现在中国、美国、新加坡都有我们的内核研发人员，未来可能还会有其它国家的同事参与进来。现在主要以 ClickHouse 头部贡献者为基础 ，加上阿里、Google 等公司的朋友组建的内核团队，一个几十人的”特种兵”团队，都是在数据库领域摸爬滚打多年的实战老手。
Databend 内核研发团队以 Worldwide Remote 模式办公， 大家通过 github 进行全球化协作，所有的工作都会在 Databend 社区进行沟通，追求开放、透明。每周五上午会有一个weekly meetup， 一般会针对某个技术点做一个分享，每次的内容也会 open 出来：<a href="https://github.com/datafuselabs/datafuse-presentations">https://github.com/datafuselabs/datafuse-presentations</a> 。从整体上讲，我们现在工作方式还是比较 open ，自由，平等，数据库研发是一个创新型工作，有了足够的自由度，创新能力才可以更好的发挥。</p><h2>问题四</h2><p><strong>小编：</strong>  目前看 Databend 开发 Roadmap 是 0.6 版本， 虎哥给我们介绍一下 0.6 版本大概包含哪些特性？</p><p><strong>BohuTang:</strong> Databend 所有的开发都是以 Github 协同。 目前 0.6 版本的 Roadmap 也在 github 上公开：<a href="https://github.com/datafuselabs/databend/issues/2525">https://github.com/datafuselabs/databend/issues/2525</a>   这里面对用户影响最大的就是用户配合 bendctl 非常方便的起 Databend， 使用 local disk 或是 S3 跑通 ontime 的数据加载， SQL 查询等。 同时引入云上的一个数据导入语法。 我计划在在 12 月 18 日参加 3306π 社区活动时给大家做一个展示。</p><h2>问题五</h2><p><strong>小编：</strong> 最后想问一下虎哥，在哪里可以更多的关注或是联系到 Databend ？</p><p><strong>BohuTang:</strong> Databend 是一款开源云原生数仓产品，项目托管在 Github 上面，目前 Github 上的 Issue ,  Discussions 都在使用， 方便大家进行 PR 或是讨论。  另外我们开放有：
Slack:
<a href="https://join.slack.com/t/datafusecloud/shared_invite/zt-nojrc9up-50IRla1Y1h56rqwCTkkDJA">https://join.slack.com/t/datafusecloud/shared_invite/zt-nojrc9up-50IRla1Y1h56rqwCTkkDJA</a></p><p>官方社区网站：  <a href="https://databend.rs">https://databend.rs</a>
Facebook group：<a href="https://fb.me/databendcloud">https://fb.me/databendcloud</a>
Twitter:  @Datafuse_Labs
公众号：Databend
微信群： 微信搜 Databend ，添加小秘书申请入群。 </p><p>如果有对 Databend 有任何的建议或是问题，不用犹豫，可通过上面的多个渠道联系哦</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[NoSQL 技术实践及未来展望--王奇|青云科技]]></title>
            <link>https://3306pai.cn/blog/wangqi-interview</link>
            <guid>wangqi-interview</guid>
            <pubDate>Tue, 07 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[演讲议题：]]></description>
            <content:encoded><![CDATA[<p><img src="https://3306pai-1255499614.cos.ap-guangzhou.myqcloud.com/sz2021/%E7%8E%8B%E5%A5%87.jpg"/></p><p><strong>演讲议题：</strong></p><p>NoSQL 技术实践及未来展望</p><p><strong>讲师简介：</strong></p><p>王奇，青云科技 | 数据库团队负责人</p><p>目前从事 PaaS 中间件服务（Redis/MongoDB/ELK 等）开发工作，对 NoSQL 数据库有深入的研究以及丰富的二次开发经验，热衷对 NoSQL 数据库领域内的最新技术动态的学习，能够把握行业技术发展趋势。</p><p><strong>议题介绍：</strong></p><p>分享先从 Redis 入手，了解 NoSQL 早期的应用场景。再到谈谈近些年来知名数据库厂商修改开源协议对国内用户影响及应对方案。最后，让来展望一下在未来数字化转型大背景下，NoSQL 们将有哪些更复杂的场景去应对。</p><h1>嘉宾专访</h1><p>欢迎青云科技的数据库团队负责人，王奇老师来到本次3306π-深圳专场</p><h2>问题一</h2><p><strong>小编</strong> 青云科技是我们的老朋友了，这次也非常荣幸邀请到王老师，小编先请王老师简单做个自我介绍，3306π的小伙伴们想更加了解下您~</p><p><strong>王奇</strong> 大家好，我是王奇，是3306π的新朋友。我于 2021 年加入青云，目前担任 Redis /ELK/MongoDB 等 NoSQL数据库方向的研发 Leader。曾就职于IBM，参与云计算相关的研发工作。对NoSQL数据库相关的技术有深入的研究，热衷对NoSQL数据库领域内的最新技术动态的学习，能够把握行业技术发展趋势。</p><h2>问题二</h2><p><strong>小编</strong> 青云的数据库团队，一定是最核心的团队之一了，也一定紧跟业界的技术动态，才为我们提供了优质的 NoSQL 数据库服务和产品，对于青云最具吸引力的数据库服务和产品中，王老师可否简单介绍一些给大家呢？</p><p><strong>王奇</strong> 好的，青云最受用户欢迎的是缓存服务，我们基于 Redis 支持了 6.x 版本的新特性，加上IAAS 的底层的改进，QPS 和服务体验比以往提升了一个档次。除了 Redis 以外，我们最新发布了大数据平台 OpenSearch服务，为用户提供安全、高质量的搜索和分析套件。还有已经步入内测阶段的高性能分支KeyDB 产品，KeyDB 是缓存中最快的内存数据库，不久的将来会在公有云与大家见面。</p><h2>问题三</h2><p><strong>小编</strong> 王老师本次的主题《NoSQL技术实践及未来展望》，关于NoSQL的产品和场景定位，王老师一定有更独到的见解，可否向大家分享一二呢？</p><p><strong>王奇</strong> 在数字化转型的背景下，越来越多的用户离不开使用 NoSQL 技术，例如大家对 Redis 其实并不陌生，它基本成为了企业核心必备的开源软件之一。所以越来越多的用户会选择基于缓存来实现他们的核心业务，如何帮助他们优化改造现有逻辑，基于需求来选型缓存产品，显得至关重要。</p><h2>问题四</h2><p><strong>小编</strong> 和王老师的交谈过程中，小编有注意到王老师对国内的用户的数据库场景和环境背景有很深入的研究，第一个环节就是选型，请问王老师选型的大致思路？</p><p><strong>王奇</strong> 是的，我们都知道数据库的场景是有需求支撑的，如果不了解是没办法进行选型和对比的，如果你想了解某一款数据库产品，可以先从需求入手，在业务的驱动下如何选择合适的数据库产品，建议先从 db-engines网站的数据库排行找些合适的，观察开源产品的社区状态，做一个 SWOT 分析，然后对比选择。</p><p>小编再次感谢青云科技的数据库团队负责人王奇老师带来的本次精彩访谈，相信有很多朋友想和王老师一起探讨一二了~ 可以有~  12.18号3306π-深圳场，王老师和小编会在这里等待着大家，而且会有其他神秘嘉宾和礼物在等待着你们哦~</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MySQL内存统计的分析与实践--刘开洋|爱可生]]></title>
            <link>https://3306pai.cn/blog/liukaiyang-interview</link>
            <guid>liukaiyang-interview</guid>
            <pubDate>Fri, 26 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[演讲议题：]]></description>
            <content:encoded><![CDATA[<p><img src="https://3306pai-1255499614.cos.ap-guangzhou.myqcloud.com/sz2021/%E5%88%98%E5%BC%80%E6%B4%8B.jpg"/></p><p><strong>演讲议题：</strong></p><p>MySQL内存统计的分析与实践</p><p><strong>讲师简介：</strong></p><p>刘开洋，爱可生|技术工程师</p><p>供职于上海爱可生，从事数据库运维和产品交付，对数据库及周边有浓厚的学习兴趣，喜欢看书，追求技术。</p><p><strong>议题介绍：</strong>
对于MySQL的内存泄漏在业内总是一件让人很头疼的事情，这次和大家分享下，我们从不同的维度对MySQL的内存统计进行相关的认识，进一步分析内存使用异常的现象，从而将其拓展到其他数据库甚至更加宽泛的C++系统中。</p><h1>嘉宾专访</h1><p>这次小编邀请到我们的老朋友-爱可生的技术专家，刘开洋老师，为我们带来《MySQL 内存统计的分析与实践》</p><h2>问题一</h2><p><strong>小编</strong> 知道，爱可生里卧虎藏龙，有非常多的技术专家走进了大家的视野，也有很多技术大佬隐藏在技术一线，首先我们邀请刘老师向3306π的小伙伴介绍下自己吧。</p><p><strong>刘开洋</strong> 大家好，我是来自爱可生交付服务部北京团队的一名技术工程师，就像小编说的，加入爱可生之后接触到很多技术牛人，便开始了内卷，技术即是服务，工作就是学习，个人对数据库及周边技术有浓厚的学习兴趣，喜欢看书，追求技术。</p><h2>问题二</h2><p><strong>小编</strong> 刘老师不仅从事数据库运维，还负责相关产品交付，小编请刘老师介绍下目前您这边主要负责爱可生的什么产品呢，有什么优势呢？</p><p><strong>刘开洋</strong> 来爱可生之后，对我司的云树系列产品都有所接触，其中北京这边的业务产品还是以DMP、RDS、DBLE以及SQLe为主，负责的客户也涉及银行、证券、保险、通信以及制造业等诸多领域，感触最深的是爱可生的DMP的自动化运维给客户带来的诸多便利，节省了很多的人力物力；DBLE也拥有很多社区贡献者，分布式使用体量很大，有独到之处，很多用户也可以进行二次开发，被深入到用户业务的各个方面。</p><h2>问题三</h2><p><strong>小编</strong> 说到产品，好的产品不仅仅在需求上拿捏用户痛点，在设计上精益求精，在产品交付的过程也是非常有学问的，而且也是被大家很容易忽视的一个能力，刘老师可否分享下您在产品如何有效交付方面的经验呢？</p><p><strong>刘开洋</strong> 对于一个优秀的交付来讲，首先需要明确产品的定位，有条理地设计用户体验，在进行POC的过程中衡量相关指标，能够经受重复的检验，以客户为导向，专注于产品是否能真正解决客户的问题。在交付完成之后并不是真正的完成交付流程，还需要不断关注客户后续的反馈与体验，在一次次地沟通中不断对自己的能力与经验进行迭代。</p><h2>问题四</h2><p><strong>小编</strong> 本次刘老师带给我们的主题《MySQL内存统计的分析与实践》，所以小编采访下刘老师，主题设想的出发点是什么呢？会带给3306π小伙伴哪些惊喜呢？</p><p><strong>刘开洋</strong> 官方一直没有过多关注MySQL内存的使用，对它的监控也不太全面，因为开源的原因，MySQL对于自身源码逻辑的设计仍不可避免地存在一定的缺陷，很容易在触发某个模块的bug导致了虚拟内存暴增，内存泄漏的问题，这次和大家分享下近期的一些内存问题带给我的一些内存统计上的思考，我们除了DBA常用的工具，还有哪些手段可以帮助我们定位MySQL的内存问题，从而扩展到对其他数据库以及C++程序的内存统计中</p><h2>问题五</h2><p><strong>小编</strong> 最后小编邀请刘老师和大伙讲讲，在您丰富的经验中，通过内存统计主要都可以解决我们哪些MySQL的常见问题呢？</p><p><strong>刘开洋</strong> 通过MySQL不同维度的内存统计，可以帮助我们更好地理解数据库内存的使用，分析解决生产环境中的内存暴增、内存泄漏等问题，降低运维工程师的血压。</p><p>通过采访刘老师，小编其实心里非常期待刘老师的现场分享，已经提前感受到了很多的实践干货，相信12.18号3306π深圳专场还会有更多的惊喜等待着大家，我们拭目以待哦</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Databend architecture]]></title>
            <link>https://3306pai.cn/blog/databend-architecture</link>
            <guid>databend-architecture</guid>
            <pubDate>Mon, 22 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Databend 整体架构]]></description>
            <content:encoded><![CDATA[<p>Databend 是一个开源的、完全面向云架构的新式数仓，它提供快速的弹性扩展能力，并结合云的弹性、简单性和低成本，使 Data Cloud 构建变得更加容易。
Databend 把数据存储在像 AWS S3 ，Azure Blob 这些云上的存储系统，可以使不同的计算节点挂载同一份数据，从而做到较高的弹性，实现对资源的精细化控制。</p><h1>Databend architecture</h1><p>Databend 是一个开源的、完全面向云架构的新式数仓，它提供快速的弹性扩展能力，并结合云的弹性、简单性和低成本，使 Data Cloud 构建变得更加容易。
Databend 把数据存储在像 AWS S3 ，Azure Blob 这些云上的存储系统，可以使不同的计算节点挂载同一份数据，从而做到较高的弹性，实现对资源的精细化控制。
Databend 在设计上专注以下能力：</p><ul><li>弹性 在 Databend 中，存储和计算资源可以按需、按量弹性扩展。</li><li>安全 Databend 中数据文件和网络传输都是端到端加密，并在 SQL 级别提供基于角色的权限控制。</li><li>易用 Databend 兼容 ANSI SQL，并可以使用 MySQL 和 ClickHouse 客户端接入，几乎无学习成本。</li><li>成本 Databend 处理查询非常高效，用户只需要为使用的资源付费。</li></ul><p><img src="https://datafuse-1255499614.cos.ap-beijing.myqcloud.com/architecture_v1.png"/></p><p>上图是 Databend 的整体架构图，整个系统主要由三大部分组成：Meta service layer、Compute Layer 和 Storage Layer。</p><h2>1、Meta Service Layer</h2><ul><li>Meta Service 是一个多租户、高可用的分布式 key-value 存储服务，具备事务能力，主要用于存储：</li><li>Metadata : 表的元信息、索引信息、集群信息、事务信息等。</li><li>Administration：用户系统、用户权限等信息。</li><li>Security ：用户登录认证、数据加密等。</li></ul><h2>2、Compute Layer</h2><p>计算层由多个集群（cluster）组成，不同集群可以承担不同的工作负载，每个集群又有多个计算节点（node）组成，你可以轻松的添加、删除节点或集群，做到资源的按需、按量管理。
计算节点是计算层的最小构成单元，其中每个计算节点包含以下几个组件：
执行计划 （Planner）
根据用户输入的 SQL 生成执行计划，它只是个逻辑表达，并不能真正的执行，而是用于指导整个计算流水线（Pipeline）的编排与生成。
比如语句</p><pre><code>SELECT number + 1 FROM numbers_mt(10) WHERE number &gt; 8 LIMIT 2 
</code></pre><p>执行计划：</p><pre><code>databend :) EXPLAIN SELECT number + 1 FROM numbers_mt(10) WHERE number &gt; 8 LIMIT 2
┌─explain────────────────────────────────────────────────────────────────────────────────────────────┐
│ Limit: 2                                                                                                                │
│   Projection: (number + 1):UInt64                                                                                       │
│     Expression: (number + 1):UInt64 (Before Projection)                                                                 │
│       Filter: (number &gt; 8)                                                                                              │
│         ReadDataSource: scan partitions: [1], scan schema: [number:UInt64], statistics: [read_rows: 10, read_bytes: 80] │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
</code></pre><p>这个执行计划自下而上分别是 ：</p><ul><li><p>ReadDataSource：表示从哪些文件里读取数据</p></li><li><p>Filter: 表示要做 (number &gt; 8) 表达式过滤</p></li><li><p>Expression: 表示要做 (number + 1) 表达式运算</p></li><li><p>Projection: 表示查询列是哪些</p></li><li><p>Limit: 表示取前 2 条数据</p></li></ul><h3>优化器 （Optimizer）</h3><p>对执行计划做一些基于规则的优化（A Rule Based Optimizer）, 比如做一些谓词下推或是去掉一些不必要的列等，以使整个执行计划更优。</p><h3>处理器 （Processors）</h3><p>处理器（Processor）是执行计算逻辑的核心组件。根据执行计划，处理器们被编排成一个流水线（Pipeline），用于执行计算任务。
整个 Pipeline 是一个有向无环图，每个点是一个处理器，每条边由处理器的 InPort 和 OutPort 相连构成，数据到达不同的处理器进行计算后，通过边流向下一个处理器，多个处理器可以并行计算，在集群模式下还可以跨节点分布式执行，这是 Datafuse 高性能的一个重要设计。</p><p>例如，我们可以通过 EXPLAIN PIPELINE 来查看：</p><pre><code>databend :) EXPLAIN PIPELINE SELECT number + 1 FROM numbers_mt(10000) WHERE number &gt; 8 LIMIT 2
┌─explain───────────────────────────────────────────────────────────────┐
│ LimitTransform × 1 processor                                                                              │
│   Merge (ProjectionTransform × 16 processors) to (LimitTransform × 1)     │
│     ProjectionTransform × 16 processors                                                             │
│       ExpressionTransform × 16 processors                                                         │
│         FilterTransform × 16 processors                                                                 │
│           SourceTransform × 16 processors                                                           │
└───────────────────────────────────────────────────────────────────────┘
</code></pre><p>同样，理解这个 Pipeline 我们自下而上来看：</p><ul><li>SourceTransform：读取数据文件，16 个物理 CPU 并行处理</li><li>ilterTransform：对数据进行 (number &gt;  8) 表达式过滤，16 个物理 CPU 并行处理 </li><li>pressionTransform：对数据进行 (number + 1) 表达式执行，16 个物理 CPU 并行处理 </li><li>ojectionTransform：对数据处理生成最终列 </li><li>LimitTransform：对数据进行 Limit 2 处理，Pipeline 进行折叠，由一个物理 CPU 来执行 </li><li>Databend 通过 Pipeline 并行模型，并结合向量计算最大限度的去压榨 CPU 资源，以加速计算。</li></ul><h3>缓存 ( Cache )</h3><p>计算节点使用本地 SSD 缓存数据和索引，以提高数据亲和性来加速计算。
缓存的预热方式有：
LOAD_ON_DEMAND - 按需加载索引或数据块（默认）。
LOAD_INDEX - 只加载索引。
LOAD_ALL - 加载全部的数据和索引，对于较小的表可以采取这种模式。</p><h2>3. Storage Layer</h2><p>Databend 使用 Parquet 列式存储格式来储存数据，为了加快查找（Partition Pruning），Databend  为每个 Parquet 提供了自己的索引（根据 Primary Key 生成）：
min_max.idx Parquet 文件 minimum 和 maximum 值
sparse.idx 以 N 条记录为颗粒度的稀疏索引
通过这些索引， 我们可以减少数据的交互，并使计算量大大减少。
假设有两个Parquet 文件：f1, f2，f1 的 min_max.idx: <!-- -->[3, 5]<!-- --> ；f2 的 min_max.idx: <!-- -->[4, 6]<!-- --> 。如果查询条件为：where x &lt; 4 ， 我们只需要 f1 文件就可以，再根据 sparse.idx 索引定位到 f1 文件中的某个数据页。</p><h2>项目地址</h2><p>代码地址：
<a href="https://github.com/datafuselabs/databend">https://github.com/datafuselabs/databend</a></p><p>项目官网：
<a href="https://datafuse.rs">https://datafuse.rs</a></p><p>想了解我们更多可以关注公众号： Databend .</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[技术分享 | MySQL进程号、连接ID、查询ID、InnoDB线程与系统线程如何对应]]></title>
            <link>https://3306pai.cn/blog/howto-find-out-os-mysql-innodb-thread</link>
            <guid>howto-find-out-os-mysql-innodb-thread</guid>
            <pubDate>Mon, 22 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[如何快速找出操作系统、MySQL进程、连接ID、查询ID、InnoDB内部线程ID之间的关系]]></description>
            <content:encoded><![CDATA[<h2>导读</h2><blockquote><p>一文快速掌握 MySQL进程号、连接ID、查询ID、InnoDB线程与系统线程的对应关系。</p></blockquote><p>有时候，怀疑某个MySQL内存查询导致CPU或磁盘I/O消耗特别高，但又不确定具体是哪个SQL引起的。</p><p>或者当InnoDB引擎内部有semaphore wait时，想知道具体是哪个线程/查询引起的。多说一下，当有semaphore wait事件超过600秒的话，InnoDB会发出crash信号：</p><pre><code>InnoDB: ###### Diagnostic info printed to the standard error stream
2020-12-13T09:41:33.810011Z 0 [ERROR] [FATAL] InnoDB: Semaphore wait has lasted &gt; 600 seconds. We intentionally crash the server because it appears to be hung.
2020-12-13 10:41:33 0x7f3d92a4e700 InnoDB: Assertion failure in thread 139902430013184 in file ut0ut.cc line 917
InnoDB: We intentionally generate a memory trap.
InnoDB: Submit a detailed bug report to http://bugs.mysql.com.
InnoDB: If you get repeated assertion failures or crashes, even
InnoDB: immediately after the mysqld startup, there may be
InnoDB: corruption in the InnoDB tablespace. Please refer to
InnoDB: http://dev.mysql.com/doc/refman/8.0/en/forcing-innodb-recovery.html
InnoDB: about forcing recovery.
09:41:33 UTC - mysqld got signal 6 ;
</code></pre><p>因此也要监控InnoDB的semaphore wait状态，一旦超过阈值，就要尽快报警并分析出问题原因，及时杀掉或停止引起等待的查询请求。</p><p>不过本文想讨论的是，MySQL的进程ID、内部查询ID、内部线程ID，和操作系统层的进程ID、线程如何对应起来。</p><h2>1、操作系统进程ID</h2><p>MySQL是一个单进程多线程的服务程序，用 <code>ps -ef|grep mysqld</code> 就能看到其系统进程ID了。另外，当 <code>my.cnf</code> 配置文件中增加一行 <code>innodb_status_file = 1</code> 时，也会生成带有系统进程ID的innodb status 文件</p><pre><code>[root@yejr.run]# ps -ef | grep mysqld
mysql    38801     1  0 Jun13 ?        00:03:30 /usr/local/GreatSQL-8.0.22/bin/mysqld --defaults-file=/mysql/data06/my.cnf

[root@yejr.run]# ls -la innodb_status.38801
-rw-r----- 1 mysql mysql 4906 Jun 14 14:26 innodb_status.38801
</code></pre><p>文件 <code>innodb_status.pid</code> 的作用是每隔15秒左右输出innodb引擎各种状态信息，和执行 <code>SHOW ENGINE INNODB STATUS</code> 的作用相同。 二者的区别在于，前者（文件输出方式）的输出内容长度不受限制，而后者（命令行输出）则最多只显示1MB内容，更多的会被截断。所以务必设置 <code>innodb_status_file = 1</code> 选项。</p><pre><code>Standard Monitor output is limited to 1MB when produced using the SHOW ENGINE INNODB STATUS statement. This limit does not apply to output written to server standard error output (stderr).
</code></pre><h2>2、系统线程和MySQL连接ID、查询ID等的关系</h2><p>从MySQL 5.7开始，<code>performance_schema.threads</code> 表增加 <code>THREAD_OS_ID</code> 列，用于记录MySQL内部线程对应的系统线程ID。</p><p>创建一个新连接，并执行下面的SQL：</p><pre><code>[root@yejr.run]# mysql -S./mysql.sock -uroot -p mymgr
...
# 查到MySQL的连接ID是25（PROCESSLIST_ID = 25）
[root@yejr.run] [none]&gt; show processlist;
+----+------+-----------+-------+---------+------+-------+------------------+-----------+---------------+
| Id | User | Host      | db    | Command | Time | State | Info             | Rows_sent | Rows_examined |
+----+------+-----------+-------+---------+------+-------+------------------+-----------+---------------+
| 25 | root | localhost | mymgr | Query   |    0 | init  | show processlist |         0 |             0 |
+----+------+-----------+-------+---------+------+-------+------------------+-----------+---------------+

[root@yejr.run] [mymgr]&gt; begin; select *,sleep(1000) from t1 for update;
...  &lt;-- 这个SQL会运行很长时间，方便我们观察
</code></pre><p>新开一个窗口，查看 <code>pfs.threads</code> 表：</p><pre><code>[root@yejr.run] [performance_schema]&gt; SELECT * FROM threads WHERE PROCESSLIST_ID=25\G
*************************** 1. row ***************************
          THREAD_ID: 65  &lt;-- MySQL内部线程ID，也是PFS的内部计数器
               NAME: thread/sql/one_connection
               TYPE: FOREGROUND
     PROCESSLIST_ID: 25  &lt;-- MySQL连接ID
   PROCESSLIST_USER: root
   PROCESSLIST_HOST: localhost
     PROCESSLIST_DB: mymgr
PROCESSLIST_COMMAND: Query
   PROCESSLIST_TIME: 246
  PROCESSLIST_STATE: User sleep
   PROCESSLIST_INFO: select *,sleep(1000) from t1 for update  &lt;-- 正在运行的SQL
   PARENT_THREAD_ID: NULL
               ROLE: NULL
       INSTRUMENTED: YES
            HISTORY: YES
    CONNECTION_TYPE: Socket
       THREAD_OS_ID: 58412  &lt;-- 对应操作系统的线程ID
     RESOURCE_GROUP: USR_default
</code></pre><p>运行 <code>ps -Lef</code> 查看对应的系统线程</p><pre><code>[root@yejr.run]# ps -Lef | grep 58412  &lt;-- 上面查询pfs.threads看到 THREAD_OS_ID 列的值
mysql    38801     1 58412  0   40 14:46 ?        00:00:00 /usr/local/GreatSQL-8.0.22/bin/mysqld --defaults-file=/mysql/data06/my.cnf
</code></pre><p>如果设置了 <code>general_log=1</code>，那么也能看到 <strong>general_log</strong> 里有这样的记录：</p><pre><code>[root@yejr.run]# cat yejr.run.log

/usr/local/GreatSQL-8.0.22/bin/mysqld, Version: 8.0.22-13 (Source distribution). started with:
Tcp port: 6001  Unix socket: mysql.sock
#几个列分别是：时间、连接ID、请求类型、详细的SQL
Time                 Id Command    Argument
...
2021-06-14T14:46:47.474393+08:00       25 Query select *,sleep(1000) from t1 for update  &lt;-- 可以看到连接ID是25
...
</code></pre><p>再查询 <code>pfs.events_statements_current</code> 表：</p><pre><code>[root@yejr.run] [performance_schema]&gt; SELECT * FROM events_statements_current WHERE THREAD_ID = 65\G
              THREAD_ID: 65
               EVENT_ID: 8
           END_EVENT_ID: NULL
             EVENT_NAME: statement/sql/select
                 SOURCE: init_net_server_extension.cc:95
            TIMER_START: 82217983305961000
              TIMER_END: 82559992238886000
             TIMER_WAIT: 342008932925000
              LOCK_TIME: 206000000
               SQL_TEXT: select *,sleep(1000) from t1 for update
                 DIGEST: 4d7f4182dff4abc484010b73024b4afb35075e1b6592d14ce895a2b8764b8f46
            DIGEST_TEXT: SELECT * , `sleep` (?) FROM `t1` FOR UPDATE
         CURRENT_SCHEMA: mymgr
...
            SELECT_SCAN: 1
...
       NESTING_EVENT_ID: 6
     NESTING_EVENT_TYPE: TRANSACTION
    NESTING_EVENT_LEVEL: 0
           STATEMENT_ID: 87  &lt;-- 查询ID，每次查询该ID值都会增加

</code></pre><p>执行 <code>SHOW ENGINE INNODB STATUS\G</code> 查看事务状态：</p><pre><code>...
# 事务ID=9322，运行时长=252秒
---TRANSACTION 9322, ACTIVE 252 sec
mysql tables in use 1, locked 1
2 lock struct(s), heap size 1136, 1 row lock(s)
# MySQL连接ID=25，OS线程句柄 = 140442126739200（后面再介绍），查询ID=87（对应上面的 STATEMENT_ID）
MySQL thread id 25, OS thread handle 140442126739200, query id 87 localhost root User sleep
select *,sleep(1000) from t1 for update
...
</code></pre><p>再看下 <code>OS thread handle</code> 和操作系统线程ID的对应关系。</p><p>首先，<code>OS thread handle 140442126739200</code> （OS thread handle是进程内部用于识别各个线程的内部ID）这里是个十进制的数值，需要先转成十六进制（有时候可能会直接用十六进制表示，这个问题也有人提出了 <a href="https://jira.mariadb.org/browse/MDEV-17237">MDEV-17237</a>）：</p><pre><code>[root@yejr.run] [performance_schema]&gt; select lower(conv(140442126739200, 10, 16));
+--------------------------------------+
| lower(conv(140442126739200, 10, 16)) |
+--------------------------------------+
| 7fbb3b136700                         |
+--------------------------------------+
</code></pre><p>再利用 <code>pstack</code> 查询该句柄和操作系统线程ID的关联：</p><pre><code>[root@yejr.run]# pstack `pidof mysqld` | grep 7fbb3b136700
Thread 2 (Thread 0x7fbb3b136700 (LWP 58412)):
</code></pre><p>可以看到 LWP = 58412，对应上面的 <code>THREAD_OS_ID</code> 值，LWP是Light-Weight Processes的缩写（轻量级进程）。用 <code>pidstat</code> 也能看到这个LWP：</p><pre><code>[root@yejr.run]# pidstat -t -p 38801 | grep 58031
03:45:02 PM  1000         -     58031    0.00    0.00    0.00    0.00     2  |__mysqld
</code></pre><p>【特别提醒】<strong>运行pstack会短暂阻塞mysqld进程，所以请切勿在业务高峰期执行，除非万不得已</strong>。</p><p>有时候可能会看到类似下面的 innodb status：</p><pre><code>SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 15143
--Thread 140585128785664 has waited at buf0flu.cc line 1209 for 237 seconds the semaphore:
SX-lock on RW-latch at 0x7fdb1fbe3f80 created in file buf0buf.cc line 1460
a writer (thread id 140584786024192) has reserved it in mode SX
number of readers 0, waiters flag 1, lock_word: 10000000
Last time read locked in file row0sel.cc line 3758
Last time write locked in file /export/home/pb2/build/sb_0-34537258-1560179931.8/mysql-5.7.27/storage/innobase/fsp/fsp0fsp.cc line 167
</code></pre><p>在上面这段信息中，线程 <code>Thread 140585128785664</code> 在 <code>buf0flu.cc代码1209行</code>这里等待了237秒，想要请求 SX-lock 的 RW-latch，被另一个线程 <code>thread id 140584786024192</code> 给阻塞了，它持有的是 SX latch。</p><p>这时候，就可以利用pstack反查对应的LWP，再反查出PROCESSLIST_ID，以及正在执行的SQL。<code>pfs.events_statements_current</code> 中只能查到当前执行的SQL，可以通过 <code>pfs.events_statements_history</code> 查看最近执行过的SQL。</p><p>Enjoy MySQL :)</p><h2>延伸阅读</h2><ul><li>15.17.3 InnoDB Standard Monitor and Lock Monitor Output, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html</a></li><li>27.12.21.6 The threads Table, <a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-threads-table.html">https://dev.mysql.com/doc/refman/8.0/en/performance-schema-threads-table.html</a></li><li>27.12.6.1 The events_statements_current Table, <a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-events-statements-current-table.html">https://dev.mysql.com/doc/refman/8.0/en/performance-schema-events-statements-current-table.html</a></li><li>27.12.6.2 The events_statements_history Table, <a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-events-statements-history-table.html">https://dev.mysql.com/doc/refman/8.0/en/performance-schema-events-statements-history-table.html</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[数据库索引总结：模型数空运最快]]></title>
            <link>https://3306pai.cn/blog/2021/11/22/songhua</link>
            <guid>数据库索引总结：模型数空运最快</guid>
            <pubDate>Mon, 22 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[大家好，我是知数堂SQL 优化班老师 网名：骑龟的兔子]]></description>
            <content:encoded><![CDATA[<p>大家好，我是知数堂SQL 优化班老师 网名：骑龟的兔子</p><p>我今天刷头条的时候 看到了一位叫《老猿说开发》总结的索引不能使用口诀
模型数空运最快</p><p>我觉得挺好，但是因为没有具体的案例，还有没说是哪个数据库这些需要完善的地方，所以写一篇文章。</p><p>模：模糊查询%在前面情况不能使用索引，这种情况非得说一个特例就是不回表情况</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;desc select dept_no from t_group2 where dept_no like &#x27;%005&#x27;;
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | t_group2 | NULL       | index | NULL          | ix_dept_no2 | 16      | NULL |   10 |    11.11 | Using where; Using index |
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+--------------------------+
</code></pre><p>型：数据类型有变化的时候不能使用</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;desc test1 ;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | varchar(10) | YES  | MUL | NULL    |       |
| n     | varchar(10) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
</code></pre><pre><code>root@mysql3306.sock&gt;[employees]&gt;select * from test1 ;
+------+------+
| id   | n    |
+------+------+
| 1000 | NULL |
| NULL | NULL |
+------+------+
2 rows in set (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;show index from test1 ;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| test1 |          1 | ix_id    |            1 | id          | A         |           2 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
1 row in set (0.01 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id=1000;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test1 | NULL       | ALL  | ix_id         | NULL | NULL    | NULL |    2 |    50.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 3 warnings (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test1 | NULL       | ref  | ix_id         | ix_id | 43      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)
</code></pre><p>数：索引列套用函数不能使用索引，这时候mysql 5.7可以用虚拟列，8.0可以直接使用函数索引，5.6的时候可以利用类似解方程方法解开</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test1 | NULL       | ref  | ix_id         | ix_id | 43      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where concat(id,&#x27;&#x27;)=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test1 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
root@mysql3306.sock&gt;[employees]&gt;create index idx_t1_ke1 on test1((concat(id,&#x27;&#x27;)));
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where concat(id,&#x27;&#x27;)=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test1 | NULL       | ref  | idx_t1_ke1    | idx_t1_ke1 | 43      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
</code></pre><p>空：索引列有空值使用is null 就不能使用索引，这个在oracle 是没问题的
但是在mysql 这个是错的</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;desc test1 ;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | varchar(10) | YES  | MUL | NULL    |       |
| n     | varchar(10) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;select * from test1 ;
+------+------+
| id   | n    |
+------+------+
| 1000 | NULL |
| NULL | NULL |
+------+------+
2 rows in set (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;show index from test1 ;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| test1 |          1 | ix_id    |            1 | id          | A         |           2 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
1 row in set (0.01 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id is null;
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | test1 | NULL       | ref  | ix_id         | ix_id | 43      | const |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id is not  null;
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | test1 | NULL       | range | ix_id         | ix_id | 43      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre><p>运：索引列有数字运算的时候不能使用索引</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
|1| SIMPLE      | test1 | NULL       | ref  | ix_id         | ix_id | 43      | const |    1 |100.00| NULL  |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select * from test1 where id+0=&#x27;1000&#x27;;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|1| SIMPLE      | test1 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |100.00| Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
</code></pre><p>最：复合索引，最左边原则，这个也需要分情况分版本，因为有skip index的存在</p><pre><code>root@mysql3306.sock&gt;[employees]&gt;show index from dept_emp2 ;
+-----------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table     | Non_unique | Key_name    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-----------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| dept_emp2 |          1 | ix_dept_emp |            1 | dept_no     | A         |           8 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| dept_emp2 |          1 | ix_dept_emp |            2 | emp_no      | A         |      315555 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+-----------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
2 rows in set (0.00 sec)
root@mysql3306.sock&gt;[employees]&gt;desc select * from dept_emp2 where emp_no=10001 limit 10 ;
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | dept_emp2 | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 331008 |    10.00 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

root@mysql3306.sock&gt;[employees]&gt;desc select emp_no,dept_no from dept_emp2 where emp_no=10001 limit 10 ;
+----+-------------+-----------+------------+-------+---------------+-------------+---------+------+-------+----------+----------------------------------------+
| id | select_type | table     | partitions | type  | possible_keys | key         | key_len | ref  | rows  | filtered | Extra                                  |
+----+-------------+-----------+------------+-------+---------------+-------------+---------+------+-------+----------+----------------------------------------+
|  1 | SIMPLE      | dept_emp2 | NULL       | range | ix_dept_emp   | ix_dept_emp | 20      | NULL | 33100 |   100.00 | Using where; Using index for skip scan |
+----+-------------+-----------+------------+-------+---------------+-------------+---------+------+-------+----------+----------------------------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre><p>快：如果优化器认为使用全表比使用索引快，那就不会使用索引，说白了就是基于优化器或者统计信息，这个就是所谓的百分比，这里最重要的一点是使用索引一般情况下是回表，也就是发生随机IO,这个随着回表的量的大小变大，一般OLTP都是在表下查询少量数据情况，所以还是使用索引的情况会好</p><p>当然上面的情况之外，还有别的情况，如日期类型，还有字符串比较的时候等等，这些在课堂中有详细的解答。
我是知数堂SQL 优化班老师~ ^^</p><p>最新一期SQL优化课，在12月份开始。</p><p>如有关于SQL优化方面疑问和一起交流的请加 并且 @兔子@知数堂SQL优化</p><p>高性能MySQL,SQL优化群 有叶金荣，吴炳锡 两位大神坐镇 ：579036588</p><p>欢迎加入 知数堂大家庭。</p><p>我的微信公众号：SQL开发与优化(sqlturning)</p>]]></content:encoded>
        </item>
    </channel>
</rss>